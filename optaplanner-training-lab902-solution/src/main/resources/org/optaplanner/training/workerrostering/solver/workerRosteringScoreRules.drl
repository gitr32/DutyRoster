/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.optaplanner.examples.workerrostering.solver;
    dialect "java"

import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder;

import org.optaplanner.training.workerrostering.domain.Employee;
import org.optaplanner.training.workerrostering.domain.Roster;
import org.optaplanner.training.workerrostering.domain.RosterParametrization;
import org.optaplanner.training.workerrostering.domain.ShiftAssignment;
import org.optaplanner.training.workerrostering.domain.Skill;
import org.optaplanner.training.workerrostering.domain.Spot;
import org.optaplanner.training.workerrostering.domain.TimeSlot;

import java.time.temporal.ChronoUnit;

global HardSoftScoreHolder scoreHolder;

// ############################################################################
// Hard constraints (Negative)
// ############################################################################

rule "Required skill for a shift"
    when
        ShiftAssignment(
                employee != null,
                !getSpot().getRequiredSkill().toString().equals("Any"),
                getEmployee().getSkillName().indexOf(getSpot().getRequiredSkill().toString()) < 0)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 0);
end

rule "Unavailable time slots for an employee"
    when
        ShiftAssignment(
                employee != null,
                getEmployee().getUnavailableTimeSlotSet().contains(getTimeSlot()))
    then
        scoreHolder.addHardConstraintMatch(kcontext, 0);
end

rule "At most one shift assignment per day per employee"
    when
        $s : ShiftAssignment(
                employee != null,
                $e : employee,
                $leftDay : getTimeSlot().getStartDateTime().toLocalDate())
        ShiftAssignment(
                employee == $e,
                getTimeSlot().getStartDateTime().toLocalDate() == $leftDay)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -200);
end

rule "No 2 shifts within 12 hours from each other"
    when
        $s : ShiftAssignment(
                employee != null,
                $e : employee,
                $leftEndDateTime : getTimeSlot().getEndDateTime())
        ShiftAssignment(
                employee == $e,
                $leftEndDateTime < getTimeSlot().getEndDateTime(),
                $leftEndDateTime.until(getTimeSlot().getStartDateTime(), ChronoUnit.HOURS) < 12)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -165);
end

rule "Get a 48 hours rest every 2 days (Forward)"
    when
        $s1 : ShiftAssignment(
                employee != null,
                $e : employee,
                $firstEnd : getTimeSlot().getEndDateTime())
        $s2 : ShiftAssignment(
                employee == $e,
                $firstEnd < getTimeSlot().getEndDateTime(),
                $firstEnd.until(getTimeSlot().getStartDateTime(), ChronoUnit.HOURS) == 12,
                $secondEnd : getTimeSlot().getEndDateTime())
        $s3: ShiftAssignment(
                employee == $e,
                $secondEnd.until(getTimeSlot().getStartDateTime(), ChronoUnit.HOURS) == 12 ||
                $secondEnd.until(getTimeSlot().getStartDateTime(), ChronoUnit.HOURS) == 24 ||
                $secondEnd.until(getTimeSlot().getStartDateTime(), ChronoUnit.HOURS) == 36
            )
    then
        scoreHolder.addHardConstraintMatch(kcontext, -55);
end

rule "Get a 48 hours rest every 2 days (Backward)"
    when
        $s1 : ShiftAssignment(
                employee != null,
                $e : employee,
                $firstStart: getTimeSlot().getStartDateTime())
        $s2 : ShiftAssignment(
                employee == $e,
                $firstStart > getTimeSlot().getStartDateTime(),
                getTimeSlot().getStartDateTime().until($firstStart, ChronoUnit.HOURS) == 12,
                $secondStart : getTimeSlot().getStartDateTime())
        $s3: ShiftAssignment(
                employee == $e,
                getTimeSlot().getEndDateTime().until($secondStart, ChronoUnit.HOURS) == 12 ||
                getTimeSlot().getEndDateTime().until($secondStart, ChronoUnit.HOURS) == 24 ||
                getTimeSlot().getEndDateTime().until($secondStart, ChronoUnit.HOURS) == 36
            )
        $s4: ShiftAssignment(
                employee == $e,
                getTimeSlot().getStartDateTime() < $firstStart,
                getTimeSlot().getStartDateTime.until($firstStart, ChronoUnit.HOURS) == 12 ||
                getTimeSlot().getStartDateTime.until($firstStart, ChronoUnit.HOURS) == 24 ||
                getTimeSlot().getStartDateTime.until($firstStart, ChronoUnit.HOURS) == 36
            )
    then
        scoreHolder.addHardConstraintMatch(kcontext, -55);
end


rule "Is not a reserve"
    when 
        $s1 : ShiftAssignment(employee != null, !employee.getIsReserve())
    then
        scoreHolder.addHardConstraintMatch(kcontext, 43);
end

// ############################################################################
// Hard constraints (Positive)
// ############################################################################

rule "Should work 2 consecutive days worth of shift (forward)"
    when

        $s1 : ShiftAssignment(
                employee != null,
                $e : employee,
                $firstEnd : getTimeSlot().getEndDateTime())
        $s2 : ShiftAssignment(
                $e == employee,
                $firstEnd < getTimeSlot().getEndDateTime(),
                $firstEnd.until(getTimeSlot().getStartDateTime(), ChronoUnit.HOURS) == 12,
                $secondEnd: getTimeSlot().getEndDateTime())
    then
        scoreHolder.addHardConstraintMatch(kcontext, 46);
end

rule "Should work 2 consecutive days worth of shift (backward)"
    when
        $s1 : ShiftAssignment(
                employee != null,
                $e : employee,
                $firstStart: getTimeSlot().getStartDateTime()
              )
        $s2 : ShiftAssignment(
                employee == $e,
                $firstStart > getTimeSlot().getStartDateTime(),
                getTimeSlot().getEndDateTime().until($firstStart, ChronoUnit.HOURS) == 12)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 46);
end

rule "Should not be working after 2 consecutive shifts (forward)"
    when
        $s1 : ShiftAssignment(
                employee != null,
                $e : employee,
                $firstStart: getTimeSlot().getStartDateTime()
              )
        $s2 : ShiftAssignment(
                employee == $e,
                $firstStart > getTimeSlot().getStartDateTime(),
                getTimeSlot().getEndDateTime().until($firstStart, ChronoUnit.HOURS) == 12,
                $secondEnd: getTimeSlot().getEndDateTime()
              )

        $s3 : ShiftAssignment(
                employee == $e,
                $secondEnd.until(getTimeSlot().getStartDateTime(), ChronoUnit.HOURS) == 12 ||
                $secondEnd.until(getTimeSlot().getStartDateTime(), ChronoUnit.HOURS) == 24 ||
                $secondEnd.until(getTimeSlot().getStartDateTime(), ChronoUnit.HOURS) == 36
            )
    then
        scoreHolder.addHardConstraintMatch(kcontext, -46);
end

rule "Should not be working after 2 consecutive shifts (backward)"
    when
        $s1 : ShiftAssignment(
                employee != null,
                $e : employee,
                $firstStart: getTimeSlot().getStartDateTime()
              )
        $s2 : ShiftAssignment(
                employee == $e,
                $firstStart > getTimeSlot().getStartDateTime(),
                getTimeSlot().getEndDateTime().until($firstStart, ChronoUnit.HOURS) == 12,
                $secondStart: getTimeSlot().getStartDateTime()
              )
        $s3 : ShiftAssignment(
                employee == $e,
                getTimeSlot().getEndDateTime().until($secondStart, ChronoUnit.HOURS) == 12 ||
                getTimeSlot().getEndDateTime().until($secondStart, ChronoUnit.HOURS) == 24 ||
                getTimeSlot().getEndDateTime().until($secondStart, ChronoUnit.HOURS) == 36
            )
    then
        scoreHolder.addHardConstraintMatch(kcontext, -46);
end

rule "Should not have a standalone shift (24 Hours)"
    when
        $s1 : ShiftAssignment(
                employee != null,
                $e : employee,
                $firstStart: getTimeSlot().getStartDateTime(),
                $firstEnd: getTimeSlot().getEndDateTime()
              )
        $s2 : ShiftAssignment(
                employee == $e,
                $firstEnd <  getTimeSlot().getStartDateTime(),
                $firstEnd.until(getTimeSlot().getStartDateTime(), ChronoUnit.HOURS) >= 24
              )
        $s3 : ShiftAssignment(
                employee == $e,
                $firstStart > getTimeSlot().getEndDateTime(),
                getTimeSlot().getEndDateTime().until($firstStart, ChronoUnit.HOURS) >= 24
            )
    then
        scoreHolder.addHardConstraintMatch(kcontext, -13);
end


// ############################################################################
// Soft constraints
// ############################################################################
/*
rule "Should be working in the same shift"
    when
        $s1 : ShiftAssignment(
                employee != null,
                $e : employee,
                $firstEnd: getTimeSlot().getEndDateTime(),
                $firstShiftHour: getTimeSlot().getStartDateTime().getHour(),
                $firstDay : getTimeSlot().getStartDateTime().toLocalDate()
                )
        $s2 : ShiftAssignment(
                employee != null,
                employee == $e,
                $firstEnd < getTimeSlot().getEndDateTime(),
                $firstShiftHour == getTimeSlot().getStartDateTime().getHour(),
                $firstDay != getTimeSlot().getStartDateTime().toLocalDate())
    then
        scoreHolder.addHardConstraintMatch(kcontext, 92);
end

rule "Fairness: all employees should work about the same number of shifts"
    when
        $e : Employee()
        accumulate(
            $a : ShiftAssignment(employee == $e);
            $total : count($a)
        )
    then
        // Fairness and load balancing trick (see docs): squared to assure correctness in corner cases
        // Negative to balance it across employees
        //scoreHolder.addSoftConstraintMatch(kcontext, - ($total.intValue() * $total.intValue()));
        //scoreHolder.addSoftConstraintMatch(kcontext, 0);
        scoreHolder.addSoftConstraintMatch(kcontext, 0);
end

rule "Affinity: assign an employee to the same spot as much as possible"
    when
        $s : Spot()
        $e : Employee()
        $t : TimeSlot()
        accumulate(
            $a : ShiftAssignment(spot == $s, employee == $e, timeSlot == $t );
            $total : count($a),
            $total >= 1
        )
        // Optionally add something like this for historic ShiftAssignments not in the working memory:
        // EmployeeSpotHistorySummary(spot == $s, employee == $e)
    then
        // Fairness and load balancing trick (see docs): squared to assure correctness in corner cases
        // Positive to anti-balance it across spot-employee pairs
        scoreHolder.addHardConstraintMatch(kcontext, 38);
end
*/